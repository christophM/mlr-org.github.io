---
layout: post
title: Use mlrMBO to optimize bash script
author: jakob
draft: true
---

```{r setup, include = FALSE, cache = FALSE, message = FALSE}
knitr::opts_chunk$set(cache = TRUE, collapse = FALSE)
knitr::knit_hooks$set(document = function(x){
  gsub("```\n*```r*\n*", "", x)
})
```

Many people who want to use **mlrMBO**, actually want to use it to optimize an algorithm that is not actually implemented in **R** but runs on the command line.

In this post I want to show in a small example how it can be done.
At the same time I will highlight some issues you can probably run into.

<!--more-->

First of all we need a bash script that we want to optimize.
This tutorial will only run on Unix systems (Linux) but should also be informative for windows users.
The following will write a tiny bash script that uses `bc` to calculate $((x_1-3)+(x_2-3))^2+ 0.1 (x_1+1)^3+0.3(x_1+0.4x_2)^3$ and write the result "hidden" in a sentence (`The result is 12.34.`) in a `result.txt` text file.

### The bash script

```{r}
#write bash
lines = '#!/bin/bash
fun ()
{
  x1=$1
  x2=$2
  command="(($x1-3)+($x2-3))^2+0.1*($x1+1)^3+0.3*($x1+0.4*$x2)^3"
  result=$(bc -l <<< $command)
}
echo "Start calculation."
fun $1 $2
echo "The result is $result." > "result.txt"
echo "Finish calculation."
'
writeLines(lines, "fun.sh")
system("chmod +x fun.sh")
```

### Running the script from R

Now we need a R function that starts the script, reads the result from the text file and returns it.

```{r runScript}
library(stringi)
runScript = function(x) {
  command = sprintf("./fun.sh %f %f", x['x1'], x['x2'])
  error.code = system(command)
  if (error.code != 0) {
    stop("Simulation had error.code != 0!")
  }
  result = readLines("result.txt")
  # the pattern matches 12 as well as 12.34
  # the ?: makes the decimals a non-capturing group.
  result = stri_match_first_regex(result, pattern = "\\d+(?:\\.\\d+)?")
  as.numeric(result)
}
```

This function uses `stringi` and _regular expressions_ to match the result within the sentence.
Depending on the output different strategies to read the result make sense.
XML files can usually be accessed with `XML::xmlParse`, `XML::getNodeSet`, `XML::xmlAttrs` etc. using `XPath` queries.
Sometimes the good old `read.table()` is also sufficient.
If, for example, the output is written in file like this:

```{bash}
value1 = 23.45
value2 = 13.82
```

You can easily use `source()` like that:

```{r, eval=FALSE}
EV = new.env()
source(file = "result.txt", local = EV)
res = as.list(EV)
rm(EV)
```

which will return a list with the entries `$value1` and `$value2`.

### Make it ready for mlrMBO

To evaluate the function from within **mlrMBO** it has to be wrapped in **smoof** function.
The smoof function also contains information about the bounds and scales of the domain of the objective function defined in a _ParameterSet_.

```{r smoof}
library(mlrMBO)
par.set = makeParamSet(
  makeNumericParam("x1", lower = -3, upper = 6),
  makeNumericParam("x2", lower = -5, upper = 5)
)
fn = makeSingleObjectiveFunction(
  id = "fun.sh", 
  fn = runScript,
  par.set = par.set,
  has.simple.signature = FALSE
)

# let's see if the function is workung
des = generateGridDesign(par.set, resolution = 3)
des$y = apply(des, 1, fn)
des
```

As we can see the console output generated by our shell script directly appears in the R-console.
This can be helpful but also annoying.

### Redirecting output

If a lot of output is generated during a single call of `system()` it might even crash R.
To avoid that I suggest to redirect the output into a file.
This way no output is lost and the R console does not get flooded.

```{r redirectOutput}
# optional: redirect console output:
runScript = function(x) {
  # console output file output_1490030005_1.1_2.4.txt
  output_file = sprintf("output_%i_%.1f_%.1f.txt", as.integer(Sys.time()), x['x1'], x['x2'])
  # redirect output with ./fun.sh 1.1 2.4 > output.txt
  # alternative: ./fun.sh 1.1 2.4 > /dev/null to drop it
  command = sprintf("./fun.sh %f %f > %s", x['x1'], x['x2'], output_file)
  error.code = system(command)
  if (error.code != 0) {
    stop("Simulation had error.code != 0!")
  }
  result = readLines("result.txt")
  # the pattern matches 12 as well as 12.34
  # the ?: makes the decimals a non-capturing group.
  result = stri_match_first_regex(result, pattern = "\\d+(?:\\.\\d+)?")
  as.numeric(result)
}
```

```{r smoof_redirectOutput, include=FALSE}
fn = makeSingleObjectiveFunction(
  id = "fun.sh", 
  fn = runScript,
  par.set = par.set,
  has.simple.signature = FALSE
)
```
 
### Start the Optimization

Now everything is set so we can proceed with the usual MBO setup:

```{r}
ctrl = makeMBOControl()
ctrl = setMBOControlInfill(ctrl, crit = crit.ei)
ctrl = setMBOControlTermination(ctrl, iters = 10)
configureMlr(show.info = FALSE, show.learner.output = FALSE)
run = mbo(fun = fn, control = ctrl)
run$x
run$y
```



